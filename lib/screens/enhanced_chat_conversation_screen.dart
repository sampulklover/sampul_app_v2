import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_markdown/flutter_markdown.dart';
import 'package:url_launcher/url_launcher.dart';
import '../models/chat_message.dart';
import '../models/chat_conversation.dart';
import '../services/openrouter_service.dart';
import '../services/chat_service.dart';
import '../controllers/auth_controller.dart';
import '../services/will_service.dart';

class EnhancedChatConversationScreen extends StatefulWidget {
  final ChatConversation conversation;

  const EnhancedChatConversationScreen({
    super.key,
    required this.conversation,
  });

  @override
  State<EnhancedChatConversationScreen> createState() => _EnhancedChatConversationScreenState();
}

class _EnhancedChatConversationScreenState extends State<EnhancedChatConversationScreen>
    with TickerProviderStateMixin {
  final TextEditingController _messageController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  final List<ChatMessage> _messages = [];
  bool _isLoading = false;
  String _streamingContent = '';
  
  late AnimationController _typingAnimationController;
  late AnimationController _messageAnimationController;
  late Animation<double> _typingAnimation;
  late Animation<double> _messageAnimation;

  @override
  void initState() {
    super.initState();
    _initializeAnimations();
    _initializeChat();
  }

  void _initializeAnimations() {
    _typingAnimationController = AnimationController(
      duration: const Duration(milliseconds: 1200),
      vsync: this,
    );
    _messageAnimationController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    
    _typingAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _typingAnimationController, curve: Curves.easeInOut),
    );
    _messageAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _messageAnimationController, curve: Curves.easeOut),
    );
  }

  void _initializeChat() async {
    // Load existing messages from Supabase first
    await _loadMessages();
  }
  
  Future<void> _loadMessages() async {
    try {
      
      final messages = await ChatService.getMessages(widget.conversation.id);
      
      if (messages.isNotEmpty) {
        // Load messages from database
        setState(() {
          _messages.clear();
          _messages.addAll(messages);
        });
      } else if (widget.conversation.conversationType == ConversationType.ai) {
        // If no messages in database for AI conversation, add welcome message
        final welcomeMessage = ChatMessage(
          id: '', // Let database generate UUID
          content: "Hello! I'm Sampul AI, your estate planning assistant. How can I help you today?",
          isFromUser: false,
          timestamp: DateTime.now(),
        );
        
        setState(() {
          _messages.add(welcomeMessage);
        });
        
        // Save to database
        await ChatService.saveMessage(welcomeMessage, widget.conversation.id);
      }
      
    } catch (e) {
      print('Error loading messages: $e');
    }
  }

  @override
  void dispose() {
    _messageController.dispose();
    _scrollController.dispose();
    _typingAnimationController.dispose();
    _messageAnimationController.dispose();
    super.dispose();
  }

  Future<void> _sendMessage() async {
    final messageText = _messageController.text.trim();
    if (messageText.isEmpty || _isLoading) return;

    _messageController.clear();

    // Add user message
    final userMessage = ChatMessage(
      id: '', // Will be generated by database
      content: messageText,
      isFromUser: true,
      timestamp: DateTime.now(),
    );

    setState(() {
      _messages.add(userMessage);
      _isLoading = true;
    });

    await ChatService.saveMessage(userMessage, widget.conversation.id);
    _scrollToBottom();
    _messageAnimationController.forward();

    // Add typing indicator
    final typingMessage = ChatMessage(
      id: 'typing_${DateTime.now().millisecondsSinceEpoch}',
      content: '',
      isFromUser: false,
      timestamp: DateTime.now(),
      isTyping: true,
    );

    setState(() {
      _messages.add(typingMessage);
    });

    _typingAnimationController.repeat(reverse: true);
    _scrollToBottom();

    try {
      // Add delay for human-like response
      await Future.delayed(const Duration(milliseconds: 500));

      // Remove typing indicator
      setState(() {
        _messages.removeWhere((msg) => msg.id == typingMessage.id);
        _streamingContent = '';
      });

      // Create streaming message
      final streamingMessage = ChatMessage(
        id: '', // Let database generate UUID
        content: '',
        isFromUser: false,
        timestamp: DateTime.now(),
        isStreaming: true,
      );

      setState(() {
        _messages.add(streamingMessage);
      });

      // Build user context from assets (concise)
      String? context;
      try {
        final user = AuthController.instance.currentUser;
        if (user != null) {
          final assets = await WillService.instance.getUserAssets(user.id);
          final int count = assets.length;
          final double total = assets.fold<double>(0.0, (double acc, Map<String, dynamic> a) => acc + ((a['value'] as num?)?.toDouble() ?? 0.0));
          final List<String> names = assets.take(5).map<String>((Map<String, dynamic> a) => (a['new_service_platform_name'] as String?) ?? (a['name'] as String?) ?? 'Asset').toList();
          context = 'Assets count: ' + count.toString() + '; Total value (approx): RM ' + total.toStringAsFixed(2) + '; Recent assets: ' + names.join(', ') + '. Use this context to tailor advice and references.';
        }
      } catch (_) {
        context = null;
      }

      // Stream the response with context
      await for (final chunk in OpenRouterService.sendMessageStream(messageText, context: context)) {
        if (mounted) {
          setState(() {
            _streamingContent += chunk;
            _messages[_messages.length - 1] = streamingMessage.copyWith(
              content: _streamingContent,
            );
          });
          _scrollToBottom();
        }
      }

      // Finalize the message
      setState(() {
        _messages[_messages.length - 1] = streamingMessage.copyWith(
          content: _streamingContent,
          isStreaming: false,
        );
        _isLoading = false;
      });

      await ChatService.saveMessage(_messages[_messages.length - 1], widget.conversation.id);

    } catch (e) {
      // Remove typing indicator
      setState(() {
        _messages.removeWhere((msg) => msg.id == typingMessage.id);
      });

      // Add error message
      final errorMessage = ChatMessage(
        id: '', // Let database generate UUID
        content: "Sorry, I'm having trouble connecting right now. Please try again later.",
        isFromUser: false,
        timestamp: DateTime.now(),
        hasError: true,
        errorMessage: e.toString(),
      );

      setState(() {
        _messages.add(errorMessage);
        _isLoading = false;
      });

      await ChatService.saveMessage(errorMessage, widget.conversation.id);
    }

    _typingAnimationController.stop();
    _scrollToBottom();
  }

  void _scrollToBottom() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (_scrollController.hasClients) {
        _scrollController.animateTo(
          _scrollController.position.maxScrollExtent,
          duration: const Duration(milliseconds: 300),
          curve: Curves.easeOut,
        );
      }
    });
  }

  void _copyMessage(ChatMessage message) {
    Clipboard.setData(ClipboardData(text: message.content));
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Message copied to clipboard')),
    );
  }


  void _deleteMessage(ChatMessage message) {
    setState(() {
      _messages.removeWhere((msg) => msg.id == message.id);
    });
    ChatService.deleteMessage(message.id);
  }

  void _toggleMessageFeedback(ChatMessage message) async {
    final newFeedback = message.userFeedback == true ? null : true;
    
    setState(() {
      final index = _messages.indexWhere((msg) => msg.id == message.id);
      if (index != -1) {
        _messages[index] = message.copyWith(userFeedback: newFeedback);
      }
    });
    
    await ChatService.updateMessageFeedback(message.id, newFeedback ?? false);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => Navigator.pop(context),
        ),
        title: Row(
          children: [
            CircleAvatar(
              radius: 16,
              backgroundColor: widget.conversation.conversationType == ConversationType.ai
                  ? Theme.of(context).colorScheme.primary
                  : Theme.of(context).colorScheme.secondary,
              child: widget.conversation.conversationType == ConversationType.ai
                  ? const Icon(Icons.smart_toy, color: Colors.white, size: 18)
                  : Text(
                      widget.conversation.name[0].toUpperCase(),
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 16,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
            ),
            const SizedBox(width: 12),
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  widget.conversation.name,
                  style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
                ),
                Text(
                  widget.conversation.isOnline ? 'Online' : 'Offline',
                  style: TextStyle(
                    fontSize: 12,
                    color: widget.conversation.isOnline ? Colors.green : Colors.grey,
                  ),
                ),
              ],
            ),
          ],
        ),
        backgroundColor: Theme.of(context).colorScheme.surface,
        elevation: 1,
        actions: [
          PopupMenuButton<String>(
            onSelected: (value) {
              switch (value) {
                case 'clear':
                  _clearConversation();
                  break;
                case 'export':
                  // TODO: Export conversation
                  break;
              }
            },
            itemBuilder: (context) => [
              const PopupMenuItem(
                value: 'clear',
                child: Row(
                  children: [
                    Icon(Icons.clear_all),
                    SizedBox(width: 8),
                    Text('Clear Conversation'),
                  ],
                ),
              ),
              const PopupMenuItem(
                value: 'export',
                child: Row(
                  children: [
                    Icon(Icons.download),
                    SizedBox(width: 8),
                    Text('Export Chat'),
                  ],
                ),
              ),
            ],
          ),
        ],
      ),
      body: Column(
        children: [
          Expanded(
            child: ListView.builder(
              controller: _scrollController,
              padding: EdgeInsets.fromLTRB(
                16,
                16,
                16,
                16 + MediaQuery.of(context).viewPadding.bottom + 80,
              ),
              itemCount: _messages.length,
              itemBuilder: (context, index) {
                final message = _messages[index];
                return _buildMessageBubble(message, _messageAnimation);
              },
            ),
          ),
          SafeArea(top: false, bottom: false, child: _buildQuickSuggestions()),
          SafeArea(top: false, child: _buildMessageInput()),
        ],
      ),
    );
  }

  Widget _buildMessageBubble(ChatMessage message, Animation<double> animation) {
    return Container(
          margin: const EdgeInsets.only(bottom: 16),
          child: Row(
            mainAxisAlignment: message.isFromUser 
                ? MainAxisAlignment.end 
                : MainAxisAlignment.start,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              if (!message.isFromUser) ...[
                  CircleAvatar(
                    radius: 16,
                    backgroundColor: widget.conversation.conversationType == ConversationType.ai
                        ? Theme.of(context).colorScheme.primary
                        : Theme.of(context).colorScheme.secondary,
                    child: widget.conversation.conversationType == ConversationType.ai
                        ? const Icon(Icons.smart_toy, color: Colors.white, size: 18)
                        : Text(
                          widget.conversation.name[0].toUpperCase(),
                          style: const TextStyle(
                            color: Colors.white,
                            fontSize: 16,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                ),
                const SizedBox(width: 8),
              ],
              Flexible(
                child: GestureDetector(
                  onLongPress: () => _showMessageContextMenu(message),
                  child: Container(
                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                    decoration: BoxDecoration(
                      color: message.isFromUser
                          ? Theme.of(context).colorScheme.primary
                          : Theme.of(context).colorScheme.surface,
                      borderRadius: BorderRadius.circular(18).copyWith(
                        bottomLeft: message.isFromUser 
                            ? const Radius.circular(18) 
                            : const Radius.circular(4),
                        bottomRight: message.isFromUser 
                            ? const Radius.circular(4) 
                            : const Radius.circular(18),
                      ),
                      boxShadow: [
                        BoxShadow(
                          color: Colors.black.withOpacity(0.1),
                          blurRadius: 4,
                          offset: const Offset(0, 2),
                        ),
                      ],
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        if (message.isTyping)
                          _buildTypingIndicator()
                        else if (message.hasError)
                          _buildErrorMessage(message)
                        else
                          _buildMessageContent(message),
                        const SizedBox(height: 4),
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Text(
                              _formatTime(message.timestamp),
                              style: TextStyle(
                                color: message.isFromUser
                                    ? Colors.white70
                                    : Theme.of(context).colorScheme.onSurface.withOpacity(0.6),
                                fontSize: 12,
                              ),
                            ),
                            if (!message.isFromUser && !message.isTyping)
                              _buildMessageActions(message),
                          ],
                        ),
                      ],
                    ),
                  ),
                ),
              ),
              if (message.isFromUser) ...[
                const SizedBox(width: 8),
                CircleAvatar(
                  radius: 16,
                  backgroundColor: Theme.of(context).colorScheme.secondary,
                  child: const Icon(Icons.person, color: Colors.white, size: 18),
                ),
              ],
            ],
          ),
        );
  }

  Widget _buildMessageContent(ChatMessage message) {
    if (message.isFromUser) {
      return Text(
        message.content,
        style: const TextStyle(
          color: Colors.white,
          fontSize: 16,
        ),
      );
    } else {
      return MarkdownBody(
        data: message.content,
        styleSheet: MarkdownStyleSheet(
          p: TextStyle(
            color: Theme.of(context).colorScheme.onSurface,
            fontSize: 16,
          ),
          strong: TextStyle(
            color: Theme.of(context).colorScheme.onSurface,
            fontWeight: FontWeight.bold,
          ),
          code: TextStyle(
            backgroundColor: Theme.of(context).colorScheme.surface,
            color: Theme.of(context).colorScheme.primary,
          ),
        ),
        onTapLink: (text, href, title) {
          if (href != null) {
            launchUrl(Uri.parse(href));
          }
        },
      );
    }
  }

  Widget _buildTypingIndicator() {
    return AnimatedBuilder(
      animation: _typingAnimation,
      builder: (context, child) {
        return Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            _buildTypingDot(0),
            const SizedBox(width: 4),
            _buildTypingDot(1),
            const SizedBox(width: 4),
            _buildTypingDot(2),
          ],
        );
      },
    );
  }

  Widget _buildTypingDot(int index) {
    return Container(
      width: 8,
      height: 8,
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.primary.withOpacity(
          0.3 + (0.7 * ((_typingAnimation.value + index * 0.2) % 1.0)),
        ),
        shape: BoxShape.circle,
      ),
    );
  }

  Widget _buildErrorMessage(ChatMessage message) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          message.content,
          style: TextStyle(
            color: Theme.of(context).colorScheme.onSurface,
            fontSize: 16,
          ),
        ),
      ],
    );
  }

  Widget _buildMessageActions(ChatMessage message) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        IconButton(
          icon: const Icon(Icons.copy, size: 16),
          onPressed: () => _copyMessage(message),
          tooltip: 'Copy',
          padding: EdgeInsets.zero,
          constraints: const BoxConstraints(),
        ),
        IconButton(
          icon: Icon(
            message.userFeedback == true ? Icons.thumb_up : Icons.thumb_up_outlined,
            size: 16,
            color: message.userFeedback == true 
                ? Theme.of(context).colorScheme.primary 
                : null,
          ),
          onPressed: () => _toggleMessageFeedback(message),
          tooltip: message.userFeedback == true ? 'Remove like' : 'Like response',
          padding: EdgeInsets.zero,
          constraints: const BoxConstraints(),
        ),
      ],
    );
  }

  Widget _buildMessageInput() {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        border: Border(
          top: BorderSide(
            color: Theme.of(context).colorScheme.outline.withOpacity(0.2),
          ),
        ),
      ),
      child: Row(
        children: [
          Expanded(
            child: Container(
              decoration: BoxDecoration(
                color: Theme.of(context).colorScheme.surface,
                borderRadius: BorderRadius.circular(24),
                border: Border.all(
                  color: Theme.of(context).colorScheme.outline.withOpacity(0.3),
                ),
              ),
              child: TextField(
                controller: _messageController,
                enabled: !_isLoading,
                maxLines: null,
                textInputAction: TextInputAction.send,
                onSubmitted: (_) => _sendMessage(),
                decoration: const InputDecoration(
                  hintText: 'Type a message...',
                  border: InputBorder.none,
                  contentPadding: EdgeInsets.symmetric(
                    horizontal: 16,
                    vertical: 12,
                  ),
                ),
              ),
            ),
          ),
          const SizedBox(width: 8),
          IconButton(
            icon: const Icon(Icons.mic),
            onPressed: () {
              // TODO: Implement voice input
            },
            tooltip: 'Voice input',
          ),
          GestureDetector(
            onTap: _isLoading ? null : _sendMessage,
            child: Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: _isLoading 
                    ? Theme.of(context).colorScheme.outline.withOpacity(0.3)
                    : Theme.of(context).colorScheme.primary,
                shape: BoxShape.circle,
              ),
              child: Icon(
                Icons.send,
                color: Colors.white,
                size: 20,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildQuickSuggestions() {
    final List<String> suggestions = <String>[
      'Summarize my assets',
      'How to start my will?',
      'What is Hibah and how to use it?',
      'Checklist for estate planning',
    ];

    return Container(
      padding: EdgeInsets.zero,
      alignment: Alignment.centerLeft,
      child: SingleChildScrollView(
        scrollDirection: Axis.horizontal,
        child: Row(
          children: suggestions
              .map((s) => Padding(
                    padding: const EdgeInsets.only(right: 8, bottom: 4),
                    child: ActionChip(
                      label: Text(s),
                      onPressed: _isLoading
                          ? null
                          : () {
                              _messageController.text = s;
                              _sendMessage();
                            },
                    ),
                  ))
              .toList(),
        ),
      ),
    );
  }

  void _showMessageContextMenu(ChatMessage message) {
    showModalBottomSheet(
      context: context,
      builder: (context) => Container(
        padding: const EdgeInsets.all(16),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              leading: const Icon(Icons.copy),
              title: const Text('Copy'),
              onTap: () {
                _copyMessage(message);
                Navigator.pop(context);
              },
            ),
            ListTile(
              leading: const Icon(Icons.delete),
              title: const Text('Delete'),
              onTap: () {
                _deleteMessage(message);
                Navigator.pop(context);
              },
            ),
          ],
        ),
      ),
    );
  }

  void _clearConversation() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Clear Conversation'),
        content: const Text('Are you sure you want to clear this conversation?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () {
              setState(() {
                _messages.clear();
              });
              ChatService.clearConversation(widget.conversation.id);
              Navigator.pop(context);
            },
            child: const Text('Clear'),
          ),
        ],
      ),
    );
  }

  String _formatTime(DateTime timestamp) {
    final now = DateTime.now();
    final difference = now.difference(timestamp);

    if (difference.inDays > 0) {
      return '${timestamp.day}/${timestamp.month}';
    } else if (difference.inHours > 0) {
      return '${timestamp.hour.toString().padLeft(2, '0')}:${timestamp.minute.toString().padLeft(2, '0')}';
    } else {
      return '${timestamp.hour.toString().padLeft(2, '0')}:${timestamp.minute.toString().padLeft(2, '0')}';
    }
  }
}
